# Writing an IÂ²C Driver

We're not going to write an entire driver, merely the first step: the `hello world` of driver writing: Reading the device ID of the sensor. This version is labelled hard, because you have to come up with the content of the methods and research information in the embedded-hal and data-sheets yourself. 

`i2c-driver/exercise/src/icm42670p.rs` is a gap text of a very basic IÂ²C IMU sensor driver. The task is to complete the file, so that running `main.rs` will log the device ID of the driver. The this gap text driver is based on the version of the same name that lives in common, but provides a little bit more functionality.

## Driver API

### Instance of the Sensor

 âœ… Create a struct that represents the sensor. It has two fields, one that represents the sensor's device address and one that represents the `IÂ²C` bus itself. This is done using traits defined in the `embedded-hal` crate. The struct is public as it needs to be accessible from outside this crate, but its fields are private. 


<Details>
    <Summary>Example Solution</Summary>
```rust 
#[derive(Debug)]
pub struct ICM42670P<I2C> {
    /// The concrete IÂ²C device implementation.
    i2c: I2C,

    /// Device address
    address: DeviceAddr,
}

```
</Details>


 âœ… Implement an instantiating method in the `impl` block. This method needs to be accessible from outside, so it's labelled `pub`. The method takes ownership of the IÂ²C bus and creates an instance of the struct you defined earlier.

<Details>
    <Summary>Example Solution</Summary>
```rust
impl<I2C, E>ICM42670P<I2C>
where
    I2C: i2c::WriteRead<Error = E> + i2c::Write<Error = E>,
{
    /// Create a new instance of the ICM42670P.
    pub fn new(i2c: I2C, address: DeviceAddr) -> Result<Self, E> {

        let icm42670p = ICM42670P { i2c, address };

        Ok(icm42670p)
    }
// ...
```
</Details>
- explain: `I2C: i2c::WriteRead<Error = E> + i2c::Write<Error = E>` ?



#### Device address

 âœ… This IÂ²C device has two possible addresses, find them in the data sheet. 
  
<Details>
    <Summary>Example Solution</Summary>

    AD0  0x68
    AD1  0x69
</Details>


ðŸ”Ž This IÂ²C device has two possible addresses. We tell the device which one we want it to use by applying either 0V or 3.3V to the AP_AD0 pin on the device. If we apply 0V, it listens to address 0x68. If we apply 3.3V it listens to address 0x69. You can therefore think of pin AD_AD0 as being a one-bit input which sets the least-significant bit of the device address.
More information is available in the [datasheet, section 9.3](https://3cfeqx1hf82y3xcoull08ihx-wpengine.netdna-ssl.com/wp-content/uploads/2021/07/DS-000451-ICM-42670-P-v1.0.pdf)


 âœ… Create an enum that represents both address variants. The values of the variants need to be in binary representation. 

<Details>
    <Summary>Example Solution</Summary>
```rust
pub enum DeviceAddr {

    /// 0x68
    AD0 = 0b110_1000,
    /// 0x69
    AD1 = 0b110_1001,
}
```
</Details>


### Registers

âœ… Create an enum that represents the sensor's registers. Each variant has the register's address as value. For now you only need the WhoAmI register. Find its address in the data sheet. 

<Details>
    <Summary>Example Solution</Summary>
```rust
#[derive(Clone, Copy)]
pub enum Register {
    WhoAmI = 0x75,
}
```
</Details>

âœ… Implement a method that exposes the variant's address as `u8`.

<Details>
    <Summary>Example Solution</Summary>
```rust
impl Register {
    fn address(&self) -> u8 {
        *self as u8
    }
}

```
</Details>


### read_register() and write_register()

âœ… Check out the write and write_read function in the embedded-hal. Why is it `write_read` and not just `read`?

<Details>
    <Summary>Answer</Summary>
The reason for this lies in the characteristics of the IÂ²C protocol: We first need to write a command over the IÂ²C bus to specify which register we want to read from. 
</Details>


âœ… Define a `read_register` and a `write_register` method for the sensor instance. Use methods provided by the `embedded-hal` crate. They serve as helpers for more specific methods and as an abstraction that is adapted to a sensor with 8-bit registers. This means that the data that is written, as well as the data that is read is an unsigned 8-bit integer. Helper methods can remain private as they don't need to be accessible from outside this crate. 

<Details>
    <Summary>Example Solution</Summary>
```rust
impl<I2C, E>ICM42670P<I2C>
where
    I2C: i2c::WriteRead<Error = E> + i2c::Write<Error = E>,
{    
    //...
    fn write_register(&mut self, register: Register, value: u8) -> Result<(), E> {
        let byte = value as u8;
        self.i2c
            .write(self.address as u8, &[register.address(), byte])
    }

    fn read_register(&mut self, register: Register) -> Result<u8, E> {
        let mut data = [0];
        self.i2c
            .write_read(self.address as u8, &[register.address()], &mut data)?;
        Ok(u8::from_le_bytes(data))
    }
}
```
</Details>


âœ… Implement a public method that reads the `WHOAMI` register with the address `0x0F`. Make use of the the above `read_register()` method.

<Details>
    <Summary>Example Solution</Summary>
```rust
impl<I2C, E>ICM42670P<I2C>
where
    I2C: i2c::WriteRead<Error = E> + i2c::Write<Error = E>,
{    
    //...
pub fn read_device_id_register(&mut self) -> Result<u16, E> {
        self.read_register(Register::WhoAmI)
    }

}
```
</Details>


âœ… Optional: Implement further methods that add features to the driver. Check the [documentation](https://3cfeqx1hf82y3xcoull08ihx-wpengine.netdna-ssl.com/wp-content/uploads/2021/07/DS-000451-ICM-42670-P-v1.0.pdf) for the respective registers and their addresses. Some ideas:
    * switching the the gyroscope sensor or the accelerometer on
    * starting measurements
    * reading measurements

#### General info about how registers work

- Registers are small amounts of storage, immediately accessible by the processor. The registers on the sensor are 8 bits.
- They can be accessed by their address
- You can find [register maps](https://3cfeqx1hf82y3xcoull08ihx-wpengine.netdna-ssl.com/wp-content/uploads/2021/07/DS-000451-ICM-42670-P-v1.0.pdf) in the section 14.
- Returning a value with MSB and LSB is done by shifting MSB values, and OR LSB values.
```rust
let GYRO_DATA_X: i16 = ((GYRO_DATA_X1 as i16) << 8) | GYRO_DATA_X0 as i16;
```
(maybe from `from_be_bytes[GYRO_data_X1, GYRO_DATA_X2] is better)
- if you need hints and inspiration, you can check the icm42670p in the common/lib

